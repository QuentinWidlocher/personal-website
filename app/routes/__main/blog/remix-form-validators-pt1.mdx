---
meta:
  title: "Les formulaires avec Remix - Partie 1"

subtitle: "Les formulaire avant, apr√®s et Remix"
---

import Code from "../../../features/blog/components/code"
import CodeTabs from "../../../features/blog/components/code-tabs"

# {attributes.meta.title}

> {attributes.subtitle}

- [Point sur les formulaires](#point-sur-les-formulaires)
  - [Exemple moderne](#exemple-moderne)
  - [Exemple √† l'ancienne](#exemple-√†-lancienne)
- [Ensuite Remix](#ensuite-remix)
  - [Parenth√®se entries()](#parenth√®se-entries)

## Point sur les formulaires

Avec Remix, ce sont les formulaires HTML que l'ont utilisait il y a maintenant plusieurs ann√©es en PHP qui reviennent sur le devant de la scene.

L√† o√π de nombreuses librairies/frameworks javascript ont souvent fait le choix de s'ajouter (voire de carr√©ment remplacer) aux champs afin d'en g√©rer l'√©tat et la validit√©, Remix lui, a plut√¥t pour but de s'en servir.

Avec Remix, ~~pas~~ peu de gestion d'√©tat comme on a souvent en React, ce sont les champs HTML qui s'occupent de stocker les donn√©es de l'utilisateur.

### Exemple moderne

Prenons par exemple un traitement assez classique d'un champs en Javascript (sans framework) :

<CodeTabs tabNames={["Template HTML", "Code Javascript"]}>

    <Code>

        ```html
        <form>
            <input type="text" name="username" />
            <button type="submit">Submit</button>
        </form>
        ```

    </Code>
    <Code>

        ```javascript
        // On r√©cup√®re le formulaire
        // (dans un cas r√©el, on fera √ßa avec un #id)
        let form = document.querySelector("form")

        // On √©coute l'envoi
        form.addEventListener("submit", (e) => {
        // On emp√™che le navigateur de g√©rer l'envoi naturellement
        e.preventDefault()

            // On t√¢che de r√©cup√©rer les donn√©es du formulaire nous m√™me
            let formData = new FormData(form)
            let formObj = Object.fromEntries(formData.entries())

            // On fait l'envoi nous-m√™me
            fetch("/action-route", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                    // Ou 'application/x-www-form-urlencoded',
                    // mais le plus souvent on envoi √† une API REST
                }
                // On s'assure d'envoyer un format reconnu
                body: JSON.stringify(formObj)
            }).then(response => {
                // On transforme la r√©ponse
                return response.json()
            }).then(responseObject => {
                // Et on s'en sert dans notre application
                doSomething(responseObject)

                // On vide les donn√©es inscrites dans le formulaire
                form.reset()
            })

        });
        ```

</Code>

</CodeTabs>

Comme vous pouvez le constater en lisant les commentaire (pas toujours tr√®s partiaux), notre boulot de d√©veloppeur est de r√©√©crire le fonctionnement du navigateur, √† la sauce Javascript.

Cette m√©thode fonctionne et il est possible de l'abstraire un peu afin de simplifier l'envoi et le retour mais c'est toujours assez similaire. Et je ne parle pas encore de la gestion des erreurs.

### Exemple √† l'ancienne

Comment utilisait-on des formulaires √† une √©poque ou Javascript n'√©tait pas aussi r√©pandu ?

<CodeTabs tabNames={["Template HTML (ou PHP, pourquoi pas)"]}>
	<Code>
		```html
		<form method="post" action="/action-route">
			<input type="text" name="username" />
			<button type="submit">Submit</button>
		</form>
		```
	</Code>
</CodeTabs>

H√© bien voil√† tout.  
Ce morceau de code est √©quivalent √† celui de l'autre exemple car c'est tout ce qui concerne la partie front de notre application.

Aucun code ici, le navigateur s'occupe lui m√™me de l'envoi des donn√©es, et de la s√©rialisation de celles-ci.

Si on change la m√©thode du formulaire en `get` et qu'on fait un envoi, on peut jeter un coup d‚Äô≈ìil √† l'URL pour voir quelles sont les donn√©es :

`https://example.com/?username=Quentin`

Plut√¥t pas mal, mais alors pourquoi on s'emb√™te √† tout refaire √† la main me demanderez vous ?  
H√© bien il y a un truc qu'on ne peut pas repr√©senter dans ces pages, mais qui pourtant est tr√®s important, c'est que la m√©thode "old school" n√©cessite un rafraichissement complet de page. üòï

Lorsqu'on appui sur "Submit", le navigateur effectue une requ√™te du type de notre attribut `method` (`post` ou `get` la plupart du temps) √† l'URL de notre attribut `action` (la m√™me URL si l'attribut n'est pas d√©fini)

Une fois cette page visit√©e avec les informations du formulaire, notre serveur va avoir l'occasion de traiter ces donn√©es puis de rediriger le client vers une autre page (pour voir le r√©sultat de notre action par exemple).  
Cette manipulation force donc le navigateur √† recharger compl√®tement la page, rendant les applications dites SPA (_Single Page Application_) tr√®s peu performantes (voire inutilisables), les script devant se recharger et se r√©-ex√©cuter.

Voil√† pourquoi aujourd'hui, quand on utilise un framework javascript, on fait les choses jusqu'au bout et on fait nos requ√™tes en javascript aussi.

## Ensuite Remix

Maintenant, comment tout cela fonctionne avec Remix ?  
Vous vous en doutez bien, si on viens de comparer un m√©thode tr√®s utilis√©e avec une autre, c'est que Remix utilise forc√©ment l'autre.

Remix se base donc sur le syst√®me de formulaire HTML, et r√©ussi √† coupler les avantages de chaque m√©thodes, √† savoir la simplicit√© des formulaire et la validation de ces derniers sans rafra√Æchissement de la page.  
Remix permet en plus de v√©rifier les types de nos formulaires et de les synchroniser entre la partie serveur et la partie client, ainsi que de facilement r√©cup√©rer les erreurs du formulaire et de les afficher.

Voil√† comment se pr√©sente un formulaire tr√®s simple avec Remix :

<Code>
    ```tsx
    // On commence par d√©clarer la fonction `action` et on peut
    // m√™me la typer en important le bon type de Remix
    export let action: ActionFunction = async ({request}) => {
        // On r√©cup√®re les donn√©es du formulaire
        let formData = await request.formData()

        // Ici, formData est un dictionnaire cl√©/valeur
        // Il est possible d'acc√©der √† nos donn√©es avec :
        let name = formData.get('name')
        console.debug(name) // "Quentin"

        // On peut aussi transformer ces donn√©es en objet:
        let formObj = Object.fromEntries(formData.entries()
        console.debug(formObj)
        // { name: "Quentin", email: "quentin@widlocher.com" }

        // Example d'appel √† un service de gestion de donn√©es
        return db.user.create(formObj)
    }

    // On d√©clare ensuite la fonction par d√©faut qui sera notre page
    export default function SimpleFormPage() {
        return (
            <form method="post">
                <label htmlFor="name">Full Name</label>
                <input type="text" name="name" />

                <label htmlFor="email">Email</label>
                <input type="email" name="email" />

                <button type="submit">Submit</button>
            </form>
        )
    }
    ```

</Code>

On d√©clare donc notre formulaire comme a vu pr√©c√©demment, et c'est la fonction `action()` qui va s'occuper de traiter les donn√©es venant de notre formulaire.

Dans `action()` rien de bien incroyable, on utilise la m√©thode `.formData()` pr√©sente sur l'objet [`Request`](https://developer.mozilla.org/fr/docs/Web/API/Request) pour r√©cup√©rer nos donn√©es.  
On peut aussi utiliser le combo `Object.fromEntries()` avec `formData.toEntries()` pour transformer les donn√©es du formulaire en un objet, ce que je trouve extr√™mement pratique, pour ma part je pr√©f√®re travailler avec des objets que des dictionnaires.

### Parenth√®se entries()

Si vous √™tes curieux, voil√† √† quoi ressemble ce qu'on appelle `entries` :

```javascript
;[
	["name", "Quentin"],
	["email", "quentin@widlocher.com"],
]
```

C'est un tableau de tuples, o√π chaque tuple est constitu√© d'une cl√© et d'une valeur.

Facile d'imaginer le r√¥le de `Object.fromEntries()` du coup.

---

Sauf que si vous essayez ce code de votre cot√©, vous allez probablement √™tre assez d√©√ßus lorsque vous allez cliquer sur Submit : la page se rafra√Æchit ! üò†

Bon, coup de bol, Remix est de toute fa√ßon tellement orient√© serveur que rafra√Æchir la page ce n'est pas la m√™me histoire que si vous utilisiez Angular, √ßa prend pas trois plombes et √ßa ne devrait pas casser trop de choses.

Mais quand m√™me, on aimerais √©viter que la page se rafraichisse si possible, √ßa serait plus agr√©able pour l'utilisateur et √ßa permettrait de garder le contr√¥le sur la page avec React, sans perdre les divers √©tat qu'on aurait pu d√©clarer.

Pour √ßa, il nous faut changer uniquement deux lettres (et un import) :

```tsx
export default function SimpleFormPage() {
	return (
		<Form method="post">
			<label htmlFor="name">Full Name</label>
			<input type="text" name="name" />

			<label htmlFor="email">Email</label>
			<input type="email" name="email" />

			<button type="submit">Submit</button>
		</Form>
	)
}
```

Vous avez vu la diff√©rence ? On n'utilise plus un `<form>` HTML mais un composant [`<Form>`](https://remix.run/docs/en/v1/api/remix#form) de remix.  
Ce composant poss√®de globalement les m√™mes attributs que son comp√®re HTML, mais s'occupe de contacter notre serveur √† l'aide d'une requ√™te `fetch` comme dans notre premier exemple.

Cette requ√™te ne rafra√Æchit donc plus la page, mais Remix s'occupe de r√©cup√©rer la r√©ponse du serveur et de le mettre √† jour (√† l'aide d'une seconde requ√™te dite de revalidation)

---

Voil√† pour cette petite (r√©)vision des formulaire tels qu'on les faisait avant, apr√®s et avec Remix.

Prochain chapitre, la validation d'un formulaire avec Remix.
