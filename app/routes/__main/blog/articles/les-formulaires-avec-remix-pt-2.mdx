---
meta:
  title: Les formulaires avec Remix - Partie 2
  description: Valider un formulaire et g√©rer les erreurs
  og:title: Les formulaires avec Remix - Partie 2
  og:description: Valider un formulaire et g√©rer les erreurs
---

# Les formulaires avec Remix - Partie 2

> Valider un formulaire et g√©rer les erreurs

%%TOC%%

Cet article fait suite √† celui-ci : [Les formulaires avec Remix - Partie 1](/blog/articles/les-formulaires-avec-remix-pt-1)

## Validation classique

Reprenons notre example pr√©c√©dent et ajoutons quelques champs afin de rentre les choses int√©ressantes :

```html
<form method="post">
	<label htmlFor="name">Full Name</label>
	<input type="text" name="name" required />

	<label htmlFor="email">Email</label>
	<input type="email" name="email" />

	<label htmlFor="phone">Phone number</label>
	<input type="number" name="phone" />

	<label htmlFor="password">Password</label>
	<input type="password" name="password" />

	<label htmlFor="passwordConfirm">Password confirmation</label>
	<input type="password" name="passwordConfirm" />

	<button type="submit">Submit</button>
</form>
```

Rien de bien m√©chant, imaginez un simple formulaire d'inscription. (Avec une confirmation de mot de passe √† l'ancienne, je d√©conseille cette approche mais c'est pratique pour mon example)

Quand on utilise l'action que l'on avait cr√©√© plus t√¥t on obtient :

```ts
export let action: ActionFunction = async ({request}) => {
    // On r√©cup√®re les donn√©es du formulaire
    let formData = await request.formData()

    // On transforme ces donn√©es en objet:
    let formObj = Object.fromEntries(formData.entries()
    console.debug(formObj)
    /*
     * {
     *      name: "Quentin",
     *      email: "quentin@widlocher",
     *      phone: "06",
     *      password: "hunter2",
     *      passwordConfirm: "hunter3",
     * }
     */

    return db.user.create(formObj)
}
```

Heu, oups. Ce n'est ni un email valide (qui pourtant a pass√© la validation cot√© navigateur), ni un num√©ro de t√©l√©phone valide, ni une confirmation de mot de passe valide...

Vous vous en doutez, il va falloir ajouter une validation de ce formulaire cot√© serveur.

Un exemple assez simple de validation possible :

```ts
// Ici, FormObject est un type qui ressemble √† nos champs
function validateForm(formObj: FormObject) {
  // S'assure qu'un nom a √©t√© donn√©e
  if (!formObj.name) {
    return;
  }

  // Valide l'email avec une regex un peu √©nerv√©e
  if (
    !/^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i.test(
      formObj.email
    )
  ) {
    return false;
  }

  // S'assure que le num√©ro de t√©l√©phone fait 10 chiffre (simpliste)
  if (String(formObj.phone).length != 10) {
    return false;
  }

  // S'assure que les mots de passe sont identiques
  if (formObj.password != formObj.passwordConfirm) {
    return false;
  }

  // S'assure que les mots de passe sont identiques
  if (formObj.password != formObj.passwordConfirm) {
    return false:
  }

  return true;
}
```

Bon, on repassera sur l'optimisation mais le code fonctionne comme on l'entend, il permet d'√©viter √† des donn√©es erron√©es d'√™tres ins√©r√©es en base de donn√©es.

Plus qu'a emp√™cher l'action de se produire en retournant une valeur avant l'ajout en base. Attention Remix a besoin que ses `action` retournent une valeur, m√™me `null`.

```ts {6-9}
export let action: ActionFunction = async ({request}) => {
    let formData = await request.formData()

    let formObj = Object.fromEntries(formData.entries()

    // On valide les donn√©es
    if (!validateForm(formObj)) {
        return null
    }

    return db.user.create(formObj)
}
```

## Affichage des erreurs classique

Bon, pas mal, mais l'utilisateur n'a aucune id√©e que son envoi s'est mal pass√© üòÖ

Il va juste cliquer sur le bouton "Submit" puis... rien du tout en fait.
Il faut donc lui afficher la liste des erreurs de son formulaire

Dans notre fonction `validateForm()`, plus question de retourner un simple bool√©en, on va devoir retourner la liste des erreurs :

```ts
// Ici, FormObject est un type qui ressemble √† nos champs
function validateForm(formObj: FormObject) {
	let errors: string[] = []

	// S'assure qu'un nom a √©t√© donn√©e
	if (!formObj.name) {
		errors.push("Un nom est requis")
	}

	// Valide l'email avec une regex un peu √©nerv√©e, sortie de mon chapeau (ou pas)
	if (!/^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i.test(formObj.email)) {
		errors.push("L'email est invalide")
	}

	// S'assure que le num√©ro de t√©l√©phone fait 10 chiffre (simpliste)
	if (String(formObj.phone).length != 10) {
		errors.push("Le num√©ro de t√©l√©phone doit faire 10 chiffres")
	}

	// S'assure que le mot de passe fait un minumum de lettres
	if (formObj.password?.length < 6) {
		errors.push("Le mot de passe doit faire au minimum 6 caract√®res")
	}

	// S'assure que les mots de passe sont identiques
	if (formObj.password != formObj.passwordConfirm) {
		errors.push("Les mots de passes ne correspondent pas")
	}

	return errors
}
```

Maintenant, on peut retourner les erreurs √† notre utilisateur via la r√©ponse de l'action

```ts
export let action: ActionFunction = async ({request}) => {
    let formData = await request.formData()

    let formObj = Object.fromEntries(formData.entries()

    // On valide les donn√©es
    let errors = validateForm(formObj)
    if (errors.length > 0) {
        // On retourne un objet avec les erreurs
        return {
          success: false,
          errors,
        }
    }

    // On retourne un objet avec le r√©sultat
    return {
      success: true,
      data: await db.user.create(formObj)
    }
}
```

Maintenant, avec un peu de _magie Typescript_ (aussi appel√© [Discriminated Union](https://thoughtbot.com/blog/the-case-for-discriminated-union-types-with-typescript)) on peut r√©cup√©rer nos erreurs proprement cot√© client

```tsx
// On d√©clare un type avec une union pour g√©rer le succ√®s et l'√©chec
// Comme √ßa quand on regarde juste `obj.success`, Typescript sait s'il
// doit chercher une propri√©t√© `data` ou `errors`
type ActionPayload =
	| {
			success: true
			data: User // on imagine un type li√© √† celui retourn√© par la bdd
	  }
	| {
			success: false
			errors: string[]
	  }

export default function SimpleFormPage() {
	// On r√©cup√®re ce que l'action nous renvoi
	let actionData = useActionData<ActionPayload>()

	// On se sert du type pour extraire une liste d'erreur
	let errors = actionData.success ? [] : actionData.errors

	// On affiche la liste des erreurs au dessus de notre formulaire
	return (
		<section>
			{errors.length > 0 ? (
				<ul>
					{errors.map((error) => (
						<li>{error}</li>
					))}
				</ul>
			) : null}
			<form method="post">{/* [...] */}</form>
		</section>
	)
}
```

Plut√¥t pas mal ! On pourrais aussi renvoyer un dictionnaire champ/erreurs sous la forme d'un objet pour avoir le d√©tail des champs et de leurs erreurs sp√©cifique.

Mais d√©j√† pour l'instant, cette solution est tout √† fait envisageable et fonctionne dans de nombreux cas.

## Validation automatique

Allons encore plus loin avec un validateur automatique, l'id√©e est de cr√©er une fonction de validation qui pourrais nous permettre de :

- D√©terminer automatiquement le type de l'objet d'erreur
- Cr√©er et g√©rer plus facilement les erreurs, voire des les grouper par champs
- G√©n√©rer automatiquement un objet format√© avec les erreurs, dans la m√™me forme que le formulaire

√âvidement pour pouvoir faire autant sans y passer des heures, on va pouvoir se servir d'un outil tr√®s performant : [zod](https://github.com/colinhacks/zod)

Zod est un ~~validateur~~ parser, qui permet de cr√©er des fonctions de validations, lui donner un objet et de r√©cup√©rer un _autre objet_ qui lui est correct.  
C'est cette nuance qui fait de zod un parser plut√¥t qu'un validateur. (Pour plus d'information technique sur cette nuance, vous pouvez [lire l'inspiration de zod ici]([https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/]))

Le fonctionnement est tr√®s simple, on construit un validateur avec les fonctions de zod pour faire un sch√©ma ressemblant √† notre objet final, exemple complet avec notre formulaire :

```ts
let validator = z.object({
	name: z.string().required("Un nom est requis"),
	email: z.string().email("L'email est invalide"),
	phone: z.string().length(10, { message: "Le num√©ro de t√©l√©phone doit faire 10 chiffres" }),
	password: z.string().min(6, { message: "Le mot de passe doit faire au minimum 6 caract√®res" }),
	passwordConfirm: z.string(),
})
```

Ici, on peux donner la plupart de nos r√®gles de validation, √† l'exception des mots de passes qui doivent √™tres identiques.

Pour affiner notre validateur, zod nous propose de cha√Æner une fonction `refine()` qui s'applique √† tout notre objet :

```ts
let validator = z
	.object({
		name: z.string().required("Un nom est requis"),
		email: z.string().email("L'email est invalide"),
		phone: z.string().length(10, { message: "Le num√©ro de t√©l√©phone doit faire 10 chiffres" }),
		password: z.string().min(6, {
			message: "Le mot de passe doit faire au minimum 6 caract√®res",
		}),
		passwordConfirm: z.string(),
	})
	.refine((obj) => obj.password === obj.passwordConfirm, {
		message: "Les mots de passes ne correspondent pas",
		path: ["passwordConfirm"],
	})
```

Le premier param√®tre de `refine()` est une fonction qui valide quelque chose √† la mani√®re d'un `assert` et le second est un objet qui nous permet de sp√©cifier un message d'erreur, mais aussi o√π le mettre (on va voir √ßa juste apr√®s)

Au passage, la validation de l'email sans fait sans douleur gr√¢ce √† zod. (Maintenant vous savez d'o√π j'ai tir√© ma regex tout √† l'heure)

Une fois qu'on a notre validateur (qui est en fait un parser), on va pouvoir l'int√©grer dans notre action pour remplacer notre fonction

```ts
export let action: ActionFunction = async ({request}) => {
    let formData = await request.formData()

    // On valide les donn√©es
    let formObj = validator.safeParse(Object.fromEntries(formData.entries())

    // Si l'objet n'est pas valide, on retourne les erreurs
    if (!formObj.success) {
      return {
        success: false,
        errors: formObj.error.format()
      }
    }

    // On retourne un objet avec le r√©sultat
    return {
      success: true,
      data: await db.user.create(formObj.data)
    }
}
```

C'est pratiquement le m√™me code, √† la diff√©rence qu'on utilise zod plut√¥t que notre fonction. Au passage, on a utilis√© `safeParse()` qui renvoi un objet qui stipule `success` ainsi que `data` ou `error`, on aurait aussi pu utiliser `parse()` qui nous aurait retourn√© notre objet, ou aurait lev√© une erreur qu'il aurait fallu catch, c'est au choix.

Mais Typescript s'√©nerve !  
Notre type de ce que renvoi notre action, `ActionPayload`, indique `errors: string[]` alors que zod ne nous renvoi plus √ßa du tout.

Que nous renvoi donc zod lorsqu'on appelle `formObj.error.format()` alors ?

```ts
{
  _errors: [],
  name: { _errors: ["Un nom est requis"] },
  email: { _errors: ["L'email est invalide"] },
  phone: { _errors: ["Le num√©ro de t√©l√©phone doit faire 10 chiffres"] },
  password: { _errors: ["Le mot de passe doit faire au minimum 6 caract√®res"] },
  // C'est pour mettre l'erreur ici qu'on a indiqu√© `path: ["passwordConfirm"]` tout √† l'heure
  passwordConfirm: { _errors: ["Les mots de passes ne correspondent pas"] },
}
```

Un objet qui, pour chaque champ (m√™me les objets), poss√®de une liste de messages d'erreurs.  
Cette fa√ßon d'√©crire les erreurs est parfaite pour afficher proprement chaque erreur sous son champ directement, plut√¥t que d'afficher une liste en haut de notre formulaire.

De plus, puisque zod a √©t√© cr√©√© avec Typescript en t√™te, il est possible d'extraire de notre validateur :

- La repr√©sentation de l'objet donn√©e par notre formulaire

  ```ts
  type FormData = z.infer<typeof validator>

  // Juste pour l'explication
  type FormDataEquivalent = {
  	name: string
  	email: string
  	phone: string
  	password: string
  	passwordConfirm: string
  }
  ```

- La repr√©sentation de l'objet d'erreurs donn√©e par notre validateur

  ```ts
  type FormDataErrors = z.ZodFormattedError<FormData>

  // Juste pour l'explication
  type FormDataErrorsEquivalent = {
  	_errors: string[]
  	name: { _errors: string[] }
  	email: { _errors: string[] }
  	phone: { _errors: string[] }
  	password: { _errors: string[] }
  	passwordConfirm: { _errors: string[] }
  }
  ```

Et bien s√ªr, ces deux types vont changer automatiquement quand on va modifier notre validateur. üòç

Il ne reste plus qu'a remplacer `errors: string[]` dans le type `ActionPayload` par `errors: FormDataErrors`.

## Affichage des erreurs automatique

Maintenant qu'on a notre validation automatique, li√© √† notre formulaire, et que cette validation nous retourne la liste des erreurs correctement format√©e, on va pouvoir afficher nos erreurs sous nos champs, fa√ßon [Material Design](https://material.io/archive/guidelines/patterns/errors.html).

```tsx
export default function SimpleFormPage() {
	// On r√©cup√®re ce que l'action nous renvoi
	let actionData = useActionData<ActionPayload>()

	// On se sert du type pour extraire nos erreurs
	let errors = actionData.success ? [] : actionData.errors

	// On affiche les erreurs sous nos champs directement
	return (
		<section>
			<form method="post">
				<label htmlFor="name">Full Name</label>
				<input type="text" name="name" required />
				{errors?.name?._errors?.length > 0 ? <small>{errors?.name?._errors[0]}</small> : null}

				<label htmlFor="email">Email</label>
				<input type="email" name="email" />
				{errors?.email?._errors?.length > 0 ? <small>{errors?.email?._errors[0]}</small> : null}

				<label htmlFor="phone">Phone number</label>
				<input type="number" name="phone" />
				{errors?.phone?._errors?.length > 0 ? <small>{errors?.phone?._errors[0]}</small> : null}

				<label htmlFor="password">Password</label>
				<input type="password" name="password" />
				{errors?.password?._errors?.length > 0 ? <small>{errors?.password?._errors[0]}</small> : null}

				<label htmlFor="passwordConfirm">Password confirmation</label>
				<input type="password" name="passwordConfirm" />
				{errors?.passwordConfirm?._errors?.length > 0 ? <small>{errors?.passwordConfirm?._errors[0]}</small> : null}

				<button type="submit">Submit</button>
				{
					// Celui l√† affiche les erreurs li√©s √† notre z.object()
					// On ne s'en sert pas dans l'exemple mais sachez le
					errors?._errors?.length > 0 ? <small>{errors?._errors[0]}</small> : null
				}
			</form>
		</section>
	)
}
```

Et voil√† on a nos erreurs sous les yeux, et directement plac√© aux bons endroits.

Il nous a juste fallu r√©cup√©rer notre liste d'erreurs et d'afficher une balise quand on a au moins une erreur dans la liste.  
On aurait bien s√ªr pu afficher la liste compl√®te dans le cas ou un champ doit respecter plusieurs r√®gles √† la fois. (ex: requis + minimum 6 lettres + regex)

## Avec un composant d'erreur

Bien entendu, vos c≈ìurs de d√©veloppeurs ont d√ª se serrer en lisant le code d'affichage des erreurs, tellement de r√©p√©tition pour un affichage pourtant si simple.  
C'est le moment id√©al pour un composant :

```tsx
type ErrorMessageProps = {
	error?: { _errors?: string[] }
	onlyFirst?: boolean
	className?: string
}

/**
 * Afffiche une liste d'erreur (ou une seule erreur) depuis un ZodFormattedErrors
 */
export default function ErrorMessage({ error, className = "", onlyFirst = true }: ErrorMessageProps) {
	return error?._errors?.length ? (
		<small className={className}>
			{onlyFirst
				? error._errors[0]
				: error._errors.map((e, i, l) => (
						<span key={e}>
							{e} {i <= l.length ? <br /> : null}
						</span>
				  ))}
		</small>
	) : null
}
```

Ce composant s'occupe simplement de prendre une extr√©mit√© d'un ZodFormattedError et d'afficher une ou toutes les erreurs √† la ligne.

Voil√† comment l'utiliser avec notre formulaire :

```tsx
export default function SimpleFormPage() {
  let actionData = useActionData<ActionPayload>();

  let errors = actionData.success ? [] : actionData.errors;

  return (
    <section>
      <form method="post">
        <label htmlFor="name">Full Name</label>
        <input type="text" name="name" required />
        <ErrorMessage error={errors?.name} />

        <label htmlFor="email">Email</label>
        <input type="email" name="email" />
        <ErrorMessage error={errors?.email} />

        <label htmlFor="phone">Phone number</label>
        <input type="number" name="phone" />
        <ErrorMessage error={errors?.phone} />

        <label htmlFor="password">Password</label>
        <input type="password" name="password" />
        <ErrorMessage error={errors?.password} />

        <label htmlFor="passwordConfirm">Password confirmation</label>
        <input type="password" name="passwordConfirm" />
        <ErrorMessage error={errors?.passwordConfirm} />

        <button type="submit">Submit</button>
        <ErrorMessage error={errors}>
      </form>
    </section>
  );
}
```

---

Et voil√†, plus qu'√† changer/ajouter/retirer de champs de votre formulaire, de synchroniser vos changement dans votre validateur et vous aurez toujours un formulaire correct, capable d'afficher ses erreurs proprement !

Dans le prochain chapitre, on verra comment pousser encore un peu plus loin pour avoir des formulaires complexe, fait d'objets imbriqu√©s, de dates et de tableaux.

<details>
<summary>Voir le code complet</summary>

```tsx
let validator = z
	.object({
		name: z.string().required("Un nom est requis"),
		email: z.string().email("L'email est invalide"),
		phone: z.string().length(10, { message: "Le num√©ro de t√©l√©phone doit faire 10 chiffres" }),
		password: z.string().min(6, {
			message: "Le mot de passe doit faire au minimum 6 caract√®res",
		}),
		passwordConfirm: z.string(),
	})
	.refine((obj) => obj.password === obj.passwordConfirm, {
		message: "Les mots de passes ne correspondent pas",
		path: ["passwordConfirm"],
	})

type FormData = z.infer<typeof validator>;
type FormDataErrors = z.ZodFormattedError<FormData>;

type ActionPayload =
  | {
      success: true;
      data: User;
    }
  | {
      success: false;
      errors: FormDataErrors;
    };

export let action: ActionFunction = async ({request}) => {
    let formData = await request.formData()

    // On valide les donn√©es
    let formObj = validator.safeParse(Object.fromEntries(formData.entries())

    // Si l'objet n'est pas valide, on retourne les erreurs
    if (!formObj.success) {
      return {
        success: false,
        errors: formObj.error.format()
      }
    }

    // On retourne un objet avec le r√©sultat
    return {
      success: true,
      data: await db.user.create(formObj.data)
    }
}

export default function SimpleFormPage() {
  let actionData = useActionData<ActionPayload>();

  let errors = actionData.success ? [] : actionData.errors;

  return (
    <section>
      <form method="post">
        <label htmlFor="name">Full Name</label>
        <input type="text" name="name" required />
        <ErrorMessage error={errors?.name} />

        <label htmlFor="email">Email</label>
        <input type="email" name="email" />
        <ErrorMessage error={errors?.email} />

        <label htmlFor="phone">Phone number</label>
        <input type="number" name="phone" />
        <ErrorMessage error={errors?.phone} />

        <label htmlFor="password">Password</label>
        <input type="password" name="password" />
        <ErrorMessage error={errors?.password} />

        <label htmlFor="passwordConfirm">Password confirmation</label>
        <input type="password" name="passwordConfirm" />
        <ErrorMessage error={errors?.passwordConfirm} />

        <button type="submit">Submit</button>
        <ErrorMessage error={errors}>
      </form>
    </section>
  );
}
```

</details>
